# a .fish complete file usually looks like a like
# `complete -c command -n '__fish_seen_subcommand_from arg' -a arg -l long -s short -d 'description'
# attempt to loosely pasrse it and convert to nu completions

# parse every .fish file in the current directory and make a .nu completions file of it
def build-completions-from-pwd [] {
    ls *.fish | par-each { |f|
        let out = ($f.name | str replace ".fish" ".nu")
        print $"building nushell completions from ($f.name)"
        build-completion $f.name $out
    }
}

# build a completion form a .fish file and generate a .nu file
def build-completion [fish_file: path, nu_file: path] {
    open $fish_file
      | find-complete-args
      | each { tokenize-complete-args | pair-tokens | translate-pairs | update-command-from-subcommand-conditions }
      | cleanup-values
      | gen
      | save $nu_file -f
}

# parse a .fish file based on autogenerated complete syntax
# returns a table of flags to arguments
# currently only handles complete's args that don't use boolean flags (e.g. -f)
def parse-fish [] {
    $in
      | find-complete-args
      | each { 
          tokenize-complete-args
          | pair-tokens
          | translate-pairs
          | transform-subcommand-conditions
      }
      | cleanup-values
}

def find-complete-args [] {
    lines | where $it starts-with 'complete ' | each { str substring 9.. }
}

# tokenize each line of the fish file into a list of tokens
# make use of detect columns -n which with one like properly tokenizers arguments including across quotes
def tokenize-complete-args [] {
    detect columns --no-headers
    | transpose --ignore-titles tokens | get tokens
    | each { unquote-value }
}

def pair-tokens [] {
  window 2 --remainder | where $it.0 starts-with '-' | each { if $in.1 starts-with '-' { [$in.0] } else { $in } }
}

def translate-pairs [] {
  each {|pair|
    match $in.0 {
      '-d' => { description: $in.1 }
      '--description' => { description: $in.1 }
      '-c' => { command: $in.1 }
      '-s' => { short-option: $in.1 }
      '-l' => { long-option: $in.1 }
      '-o' => { old-option: $in.1 }
      '-f' => { no-files: true }
      '-F' => { force-files: true }
      '-r' => { require-parameter: true }
      '-x' => { require-parameter: true, no-files: true }
      '-a' => { arguments: $in.1 }
      '-n' => { condition: $in.1 }
      '-k' => { keep-order: true }
      '--keep-order' => { keep-order: true }
      '-C' => { do-complete: $in.1 } # try to find all possible completions for the specified string. Otherwise use the current command line.
      '--escape' => { escape: true } # when used with -C escape special characters
      _ => { $'unknown_($in.0)': (if ($in | length) == 2 { $pair.1 }) }
    }
  }
  | reduce {|it,acc| $acc | merge $it }
}

def update-command-from-subcommand-conditions [] {
  mut $table = $in
  if 'condition' in ($table | columns) {
    let cond = $table | get condition
    let subcommands = $cond | split-conditions | find-subcommands
    if $subcommands != '' {
      $table = $table | update command {|x| $'($x.command) ($subcommands)' }
    }
  }
  $table
}

def findsert-subcommand-conditions [] {
  if 'condition' in ($in | columns) {
    insert subcommands { $in | get condition | split-conditions | find-subcommands }
  }
}

def tokenize-conditions [] {
  $in | detect columns --no-headers | transpose --ignore-titles tokens | get tokens
}

def split-conditions [] {
  split row '&&' | each { split row '||' } | flatten
}

def find-subcommands [] : list<string> -> string {
  where ($it | str contains '__fish_seen_subcommand_from') 
    | where ($it | str starts-with 'not') != true
    | where ($it | str contains '$') != true
    | where ($it | str contains '(') != true
    | parse --regex '__fish_seen_subcommand_from (?<name>\w+)' | get name
    | str join ' '
}

def cleanup-values [] {
  each {|row|
    let cols = $row | columns
    mut r = $row
    for col in $cols { $r = $r | update $col { $row | get $col | cleanup-value } }
    $r
  }
}

def cleanup-value [] {
  match ($in | describe) {
    'string' => ($in | if $in starts-with '(' { 'unspecified/various' } else { $in }
        ),
    _ => $in
  }
}

def unquote-value [] : any -> any {
  match ($in | describe) {
    'string' => ($in | str trim -c "\'" | str trim -c "\"" ),
    _ => $in
  }
}

def gen [] : any -> string {
  let grouped = group-by command
  let commands = $grouped | columns
  $commands
    | each {|cmd| $grouped | get $cmd | gen-cmd $cmd }
    | str join "\n"
}
def gen-cmd [$cmd: string] : any -> string {
    #let cmd = $in | columns
    ##for cmd in $cmds {
      #print $'Generating for command ($cmd)â€¦'
      let list = $in #| get $cmd
      let l = $list | each { gen-flags } | where {|x| $x | is-not-empty }
      [
        $'extern "($cmd)" ['
        ($l | str join "\n")
        "\t...args"
        "]\n"
      ] | str join "\n"
    #}
}
def gen-flags [] : any -> string {
  let table = $in
  let $cols = $table | columns
  [
    (
      if 'long-option' in $cols {
        $"\t--($table.long-option)(if 'short-option' in $cols { $"\(-($table.short-option)\)" })($table | gen-flags-desc $cols)"
      } else if 'short-option' in $cols {
        $"\t-($table.short-option)($table | gen-flags-desc $cols)"
      }
    )
  ] | str join "\n"
}

def gen-flags-desc [$cols] : any -> string {
  if 'description' in $cols { $"\t# ($in.description)" }
}

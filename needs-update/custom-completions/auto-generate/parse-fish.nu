# a .fish complete file usually looks like a like
# `complete -c command -n '__fish_seen_subcommand_from arg' -a arg -l long -s short -d 'description'
# attempt to loosely pasrse it and convert to nu completions

# parse every .fish file in the current directory and make a .nu completions file of it
def build-completions-from-pwd [] {
    ls *.fish | par-each { |f|
        let out = ($f.name | str replace ".fish" ".nu")
        print $"building nushell completions from ($f.name)"
        build-completion $f.name $out
    }
}

# build a completion form a .fish file and generate a .nu file
def build-completion [fish_file: path, nu_file: path] {
    open $fish_file | find-complete-args | each { tokenize-complete-args | pair-tokens | translate-pairs } | cleanup-values | gen | save $nu_file -f
}

# parse a .fish file based on autogenerated complete syntax
# returns a table of flags to arguments
# currently only handles complete's args that don't use boolean flags (e.g. -f)
def parse-fish [] {
    $in
      | find-complete-args
      | each { 
          tokenize-complete-args
          | pair-tokens
          | translate-pairs
      }
      | cleanup-values
}

def find-complete-args [] {
    lines | where $it starts-with 'complete ' | each { str substring 9.. }
}

# tokenize each line of the fish file into a list of tokens
# make use of detect columns -n which with one like properly tokenizers arguments including across quotes
def tokenize-complete-args [] {
    detect columns --no-headers
    | transpose --ignore-titles tokens | get tokens
    | each { unquote-value }
}

def pair-tokens [] {
  window 2 --remainder | where $it.0 starts-with '-' | each { if $in.1 starts-with '-' { [$in.0] } else { $in } }
}

def translate-pairs [] {
  each {|pair|
    match $in.0 {
      '-d' => { description: $in.1 }
      '--description' => { description: $in.1 }
      '-c' => { command: $in.1 }
      '-s' => { short-option: $in.1 }
      '-l' => { long-option: $in.1 }
      '-o' => { old-option: $in.1 }
      '-f' => { no-files: true }
      '-r' => { require-parameter: true }
      '-x' => { require-parameter: true, no-files: true }
      '-a' => { arguments: $in.1 }
      '-n' => { condition: $in.1 }
      '-k' => { keep-order: true }
      '-C' => { do-complete: $in.1 } # try to find all possible completions for the specified string. Otherwise use the current command line.
      '--escape' => { escape: true } # when used with -C escape special characters
      _ => { $'unknown_($in.0)': (if ($in | length) == 2 { $pair.1 }) }
    }
  }
  | reduce {|it,acc| $acc | merge $it }
}

def cleanup-values [] {
  each {|row|
    let cols = $row | columns
    mut r = $row
    for col in $cols { $r = $r | update $col { $row | get $col | cleanup-value } }
    $r
  }
}

def cleanup-value [] {
  match ($in | describe) {
    'string' => ($in | if $in starts-with '(' { 'unspecified/various' } else { $in }
        ),
    _ => $in
  }
}

def unquote-value [] : any -> any {
  match ($in | describe) {
    'string' => ($in | str trim -c "\'" | str trim -c "\"" ),
    _ => $in
  }
}

def gen [] : any -> string {
  group-by command
    | each { gen-cmd }
    | str join "\n"
}
def gen-cmd [] : record -> string {
    let cmd = $in | columns | first
    let list = $in | get $cmd
    let l = $list | each { gen-flags } | where {|x| $x | is-not-empty }
    { cmd: $cmd l: $l }
    [
      $'extern "($cmd)" ['
      ($l | str join "\n")
      "\t...args"
      ']'
    ] | str join "\n"
}
def gen-flags [] : any -> string {
  let table = $in
  let $cols = $table | columns
  [
    (
      if 'long-option' in $cols {
        $"\t--($table.long-option)(if 'short-option' in $cols { $"\(-($table.short-option)\)" })($table | gen-flags-desc $cols)"
      } else if 'short-option' in $cols {
        $"\t-($table.short-option)($table | gen-flags-desc $cols)"
      }
    )
  ] | str join "\n"
}

def gen-flags-desc [$cols] : any -> string {
  if 'description' in $cols { $"\t# ($in.description)" }
}

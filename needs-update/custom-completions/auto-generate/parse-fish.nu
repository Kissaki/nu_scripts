# a .fish complete file usually looks like a like
# `complete -c command -n '__fish_seen_subcommand_from arg' -a arg -l long -s short -d 'description'
# attempt to loosely pasrse it and convert to nu completions

# parse every .fish file in the current directory and make a .nu completions file of it
def build-completions-from-pwd [] {
    ls *.fish | par-each { |f|
        let out = ($f.name | str replace ".fish" ".nu")
        print $"building nushell completions from ($f.name)"
        build-completion $f.name $out
    }
}

# build a completion form a .fish file and generate a .nu file
def build-completion [fish_file: path, nu_file: path] {
    open $fish_file | parse-fish | make-commands-completion | str join "\n\n" | save $nu_file
}

# parse a .fish file based on autogenerated complete syntax
# returns a table of flags to arguments
# currently only handles complete's args that don't use boolean flags (e.g. -f)
def parse-fish [] {
    $in
      | find-complete-args
      | each { 
          tokenize-complete-args
          | pair-tokens
          | translate-pairs
      }
      | cleanup-values
}

def find-complete-args [] {
    lines | where $it starts-with 'complete ' | each { str substring 9.. }
}

# tokenize each line of the fish file into a list of tokens
# make use of detect columns -n which with one like properly tokenizers arguments including across quotes
def tokenize-complete-args [] {
    #str replace -a "\\\\'" ""             # remove escaped quotes ' which break detect columns
    detect columns --no-headers
    | transpose --ignore-titles tokens | get tokens
}

def pair-tokens [] {
  window 2 --remainder | where $it.0 starts-with '-' | each { if $in.1 starts-with '-' { [$in.0] } else { $in } }
}

def translate-pairs [] {
  each {|pair|
    match $in.0 {
      '-d' => { description: $in.1 }
      '--description' => { description: $in.1 }
      '-c' => { command: $in.1 }
      '-s' => { short-option: $in.1 }
      '-l' => { long-option: $in.1 }
      '-o' => { old-option: $in.1 }
      '-f' => { no-files: true }
      '-r' => { require-parameter: true }
      '-x' => { require-parameter: true, no-files: true }
      '-a' => { arguments: $in.1 }
      '-n' => { condition: $in.1 }
      '-k' => { keep-order: true }
      '-C' => { do-complete: $in.1 } # try to find all possible completions for the specified string. Otherwise use the current command line.
      '--escape' => { escape: true } # when used with -C escape special characters
      _ => { $'unknown_($in.0)': (if ($in | length) == 2 { $pair.1 }) }
    }
  }
  | reduce {|it,acc| $acc | merge $it }
}

def cleanup-values [] {
  each {|row|
    let cols = $row | columns
    mut r = $row
    for col in $cols { $r = $r | update $col { $row | get $col | cleanup-value } }
    $r
  }
}

def cleanup-value [] {
  match ($in | describe) {
    'string' => ($in | str trim -c "\'"
        | str trim -c "\""
        | if $in starts-with '(' { 'unspecified/various' } else { $in }
        ),
    _ => $in
  }
}

def gen [] {
  group-by command
    | each { gen-cmd }
}
def gen-cmd [] : record<ninja: list<any>> -> any {
    let cmd = $in | columns | first
    let l = $in | get $cmd | each { gen-arg }
    print ({ cmd: $cmd l: $l } | describe)
    { cmd: $cmd l: $l }
    
}
def gen-arg [] {
  let $cols = $in | columns
  if 'long-option' in $cols {
    
  }
}

# from a parsed fish table, create the completion for it's command and sub commands
def make-commands-completion [] {
    let fishes = $in
    $fishes
    | get command
    | uniq         # is cloned on every complete line
    | each { |command|
        $fishes | where command == $command | make-subcommands-completion [$command]
        | str join "\n\n"
    }
}

# make the action nu completion string from subcommand and args
# subcommand can be empty which will be the root command
def make-subcommands-completion [parents: list<string>] {
    let quote = '"' # a `"`

    let fishes = $in

    $fishes
    | group-by a                                                                      # group by sub command (a flag)
    | transpose name args                                                             # turn it into a table of name to arguments
    | each {|subcommand|
        [
            # description
            (if ('d' in ($subcommand.args | columns)) and ($subcommand.args.d != "") { $"# ($subcommand.args.d.0)\n" })
            # extern name
            $'extern "($parents | append $subcommand.name | str join " " | str trim)"'
            # params
            " [\n"
                (
                    $fishes
                    | if ('n' in ($subcommand | columns)) {
                        if ($subcommand.name != "") {
                            where ($it.n | str contains $subcommand.name)                     # for subcommand -> any where n matches `__fish_seen_subcommand_from arg` for the subcommand name
                        } else {
                            where ($it.n == "__fish_use_subcommand") and ($it.a == "")         # for root command -> any where n ==  __fish_use_subcommand and a is empty. otherwise a means a subcommand
                        }
                    } else {
                        $fishes                                                               # catch all
                    }
                    | build-flags
                    | str join "\n"
                )
                "\n\t...args"
            "\n]"
        ]
        | str join
    }
}

# build the list of flag string in nu syntax
# record<c, n, a, d, o> -> list<string>
def build-flags [] {
    $in
    | each { |subargs|
        if ('l' in ($subargs | columns)) and ($subargs.l != "") {
            [
                "\t--" $subargs.l
                (
                  [
                    (if ('s' in ($subargs | columns)) and ($subargs.s != "") { [ "(-" $subargs.s ")" ] | str join })
                    (if ('d' in ($subargs | columns)) and ($subargs.d != "") { [ "\t\t\t\t\t# " $subargs.d ] | str join })
                  ] | str join
                )
            ] | str join
        }
    }
}

# a .fish complete file usually looks like a like
# `complete -c command -n '__fish_seen_subcommand_from arg' -a arg -l long -s short -d 'description'
# attempt to loosely pasrse it and convert to nu completions

# parse every .fish file in the current directory and make a .nu completions file of it
def build-completions-from-pwd [] {
    ls *.fish | par-each { |f|
        let out = ($f.name | str replace ".fish" ".nu")
        print $"building nushell completions from ($f.name)"
        build-completion $f.name $out
    }
}

def "nufish parse" [fish_file: path] {
  let fish = open $fish_file
  let vars = $fish | parse-vars
  let completes = $fish
    | find-complete-calls
    | each { tokenize-complete-args | pair-tokens | translate-pairs | findsert-subcommands }
    #| cleanup-values
  print $'Parsed ($completes | length) complete calls'
  let subcommands = $completes | where ('arguments' in ($it | columns)) | each {|x| $'($x | get command) ($x | get arguments)' }
  let commands = $completes | get command | uniq | append $subcommands
  $commands
}

# build a completion form a .fish file and generate a .nu file
def build-completion [fish_file: path, nu_file: path] {
    open $fish_file
      | find-complete-calls
      | each { tokenize-complete-args | pair-tokens | translate-pairs | update-command-from-subcommand-conditions }
      | cleanup-values
      | gen
      | save $nu_file -f
}

def fill-vars [$vars] {
  let x = $in
  if ($x starts-with '$') { $vars | where var == ($x | str substring 1..) | get values } else { $x }
}

# parse a .fish file based on autogenerated complete syntax
# returns a table of flags to arguments
# currently only handles complete's args that don't use boolean flags (e.g. -f)
def parse-fish [] {
    $in
      | find-complete-calls
      | each { 
          tokenize-complete-args
          | pair-tokens
          | translate-pairs
          | transform-subcommand-conditions
      }
      | cleanup-values
}

def find-complete-calls [] {
    lines | where $it starts-with 'complete ' | each { str substring 9.. }
}

# tokenize each line of the fish file into a list of tokens
# make use of detect columns -n which with one like properly tokenizers arguments including across quotes
def tokenize-complete-args [] {
    detect columns --no-headers
    | transpose --ignore-titles tokens | get tokens
    | each { unquote-value }
}

def pair-tokens [] {
  window 2 --remainder | where $it.0 starts-with '-' | each { if $in.1 starts-with '-' { [$in.0] } else { $in } }
}

def translate-pairs [] {
  each {|pair|
    match $in.0 {
      '-c' | '--command' => { command: $in.1 }
      '-s' | '--short-option' => { short-option: $in.1 }
      '-l' | '--long-option' => { long-option: $in.1 }
      '-d' | '--description' => { description: $in.1 }
      '-o' | '--old-option' => { old-option: $in.1 }
      '-F' | '--force-files' => { force-files: true }
      '-f' | '--no-files' => { no-files: true }
      '-r' | '--require-parameter' => { require-parameter: true }
      '-x' | '--exclusive' => { require-parameter: true, no-files: true }
      '-a' | '--arguments' => { arguments: $in.1 }
      '-n' | '--condition' => { condition: $in.1 }
      '-k' | '--keep-order' => { keep-order: true }
      '-C' | '--do-complete' => { do-complete: $in.1 } # try to find all possible completions for the specified string. Otherwise use the current command line.
      '--escape' => { escape: true } # when used with -C escape special characters
      _ => { $'unknown_($in.0)': (if ($in | length) == 2 { $pair.1 }) }
    }
  }
  | reduce {|it,acc| $acc | merge $it }
}

def update-command-from-subcommand-conditions [] {
  mut $table = $in
  if 'condition' in ($table | columns) {
    let cond = $table | get condition
    let subcommands = $cond | split-conditions | find-subcommands
    if $subcommands != '' {
      $table = $table | update command {|x| $'($x.command) ($subcommands)' }
    }
  }
  $table
}

def findsert-subcommands [] {
  let table = $in
  if 'condition' in ($table | columns) {
    let condition = $table | get condition
    if ($condition == '__fish_use_subcommand' and 'arguments' in ($table | columns)) {
      $table | insert subcommands { get arguments }
    }
    $table | insert subcommands { $condition | split-conditions | find-subcommands }
  }
}

def tokenize-conditions [] {
  $in | detect columns --no-headers | transpose --ignore-titles tokens | get tokens
}

def split-conditions [] {
  split row '&&' | each { split row '||' } | flatten
}

def find-subcommands [] : list<string> -> string {
  where ($it | str contains '__fish_seen_subcommand_from')
    | where ($it | str starts-with 'not') != true
    | where ($it | str contains '$') != true
    | where ($it | str contains '(') != true
    | parse --regex '__fish_seen_subcommand_from (?<name>\w+)' | get name
    | str join ' '
}

def cleanup-values [] {
  each {|row|
    let cols = $row | columns
    mut r = $row
    for col in $cols { $r = $r | update $col { $row | get $col | cleanup-value } }
    $r
  }
}

def cleanup-value [] {
  match ($in | describe) {
    'string' => ($in | if $in starts-with '(' { 'unspecified/various' } else { $in }
        ),
    _ => $in
  }
}

def unquote-value [] : any -> any {
  match ($in | describe) {
    'string' => ($in | str trim -c "\'" | str trim -c "\"" ),
    _ => $in
  }
}

def gen [] : any -> string {
  let grouped = group-by command
  let commands = $grouped | columns
  $commands
    | each {|cmd| $grouped | get $cmd | gen-cmd $cmd }
    | str join "\n"
}
def gen-cmd [$cmd: string] : any -> string {
    #let cmd = $in | columns
    ##for cmd in $cmds {
      #print $'Generating for command ($cmd)â€¦'
      let list = $in #| get $cmd
      let l = $list | each { gen-flags } | where {|x| $x | is-not-empty }
      [
        $'extern "($cmd)" ['
        ($l | str join "\n")
        "\t...args"
        "]\n"
      ] | str join "\n"
    #}
}
def gen-flags [] : any -> string {
  let table = $in
  let $cols = $table | columns
  [
    (
      if 'long-option' in $cols {
        $"\t--($table.long-option)(if 'short-option' in $cols { $"\(-($table.short-option)\)" })($table | gen-flags-desc $cols)"
      } else if 'short-option' in $cols {
        $"\t-($table.short-option)($table | gen-flags-desc $cols)"
      }
    )
  ] | str join "\n"
}

def gen-flags-desc [$cols] : any -> string {
  if 'description' in $cols { $"\t# ($in.description)" }
}

def parse-vars [] {
  lines | parse 'set -l {var} {values}' | update values { split words }
}

def parse-commands [] {
  lines | parse --regex '\s*complete.+((-c)|(--command)) (?<cmd>\w+)' | get cmd | where ($it | is-not-empty) | str trim -c "\'" | str trim -c "\""
}
